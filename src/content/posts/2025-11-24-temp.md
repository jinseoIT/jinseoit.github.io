---
title: "JavaScript에서 동일성과 동등성"
description: "Temp"
author: "Temp"
image: "/blog-placeholder-1.jpg"
published: 2025-11-24T02:52:50.953Z
tags: []
draft: true
---

# JavaScript에서 동일성(Identity)과 동등성(Equality)

객체 비교의 두 가지 관점인 **동일성**과 **동등성** 개념을 이해하고, JavaScript의 `==`, `===`, `Object.is`의 차이점과 NaN의 특수한 동작 원리를 알아봅니다.

---

## 1. 동일성과 동등성의 개념

### 자바에서의 정의

자바 진영에서는 오래전부터 객체 비교를 두 축으로 구분해왔습니다.

**동일성 (Identity)**
> "완전히 같은 개체냐?"

- 메모리 상에서 **같은 인스턴스(같은 참조)** 를 가리키는지 확인
- 자바: `==` 연산자 (참조 타입 기준)

**동등성 (Equality)**
> "도메인 관점에서 같은 것으로 취급해도 되냐?"

- 물리적으로는 다른 객체지만, 비즈니스 규칙상 같은 엔티티
- 자바: `equals()` / `hashCode()` 오버라이드로 정의

---

### 자동차 예시

```
차량 A: 2025년식 흰색 Model X 롱레인지 (VIN: ABC123)
차량 B: 2025년식 흰색 Model X 롱레인지 (VIN: XYZ789)
```

**분석**
- 차종, 옵션, 색상, 연식이 모두 동일
- 하지만 **차대번호(VIN)** 는 다름

**결론**
- ❌ **동일하지 않음**: 서로 다른 차대번호를 가진 별개의 차량
- ✅ **동등할 수 있음**: "2025년식 흰색 Model X 롱레인지"라는 도메인 관점에서는 같은 사양

---

### 정리

| 구분       | 질문                       | 기준        |
| ---------- | -------------------------- | ----------- |
| **동일성** | "저 차 그대로냐?"          | 식별자/참조 |
| **동등성** | "같은 물건으로 봐도 되냐?" | 도메인 규칙 |

---

## 2. JavaScript에서의 적용

### 동일성 비교

객체/배열/함수는 **같은 참조**를 가리킬 때만 같다고 판단합니다.

```javascript
const a = { value: 1 };
const b = { value: 1 };
const c = a;

a === b; // false (구조가 같아도 다른 객체)
a === c; // true (같은 참조)
```

### 동등성 비교

비즈니스 로직에 따라 우리가 직접 정의해야 합니다.

```javascript
const user1 = { id: 1, name: "Jin" };
const user2 = { id: 1, name: "Jinny" };

// 동일성
user1 === user2; // false (다른 객체)

// 도메인 동등성 (ID 기준)
const isSameUser = (a, b) => a?.id === b?.id;
isSameUser(user1, user2); // true
```

---

### 핵심 포인트

> **동일성(참조)과 동등성(도메인 규칙)을 분리해서 생각하자**

이를 분리하지 않으면 `===` 만으로 판단하다가 Set/Map, 상태 비교, React 최적화에서 의도와 다른 결과를 얻게 됩니다.

---

## 3. JavaScript의 동등성 연산자 비교

JavaScript에는 세 가지 비교 방식이 있습니다.

| 연산자        | 타입 변환 | 특징                   |
| ------------- | --------- | ---------------------- |
| `==`          | O         | 느슨한 동등성          |
| `===`         | X         | 엄격한 동등성          |
| `Object.is()` | X         | SameValue 기반 비교    |

---

### 3-1. `==` - 느슨한 동등성 (Loose Equality)

타입이 다르면 **강제 형변환** 후 비교합니다.

```javascript
"1" == 1;           // true - 문자열 → 숫자
0 == false;         // true - false → 0
0 == "";            // true - "" → 0
null == undefined;  // true - 특별 취급
[] == "";           // true - [] → ""
[] == 0;            // true - [] → "" → 0
```

**권장사항**
- 팀 규칙으로 `==` 사용 **금지**
- 예외: `value == null` (null + undefined 동시 체크)
- ESLint: `eqeqeq: "error"` 설정

---

### 3-2. `===` - 엄격한 동등성 (Strict Equality)

타입 변환 없이 비교합니다.

**비교 규칙**
- 타입이 다르면 → `false`
- 타입이 같으면 → 타입별 규칙 적용
  - 숫자: 같은 값이면 `true`, `+0 === -0` → `true`, `NaN === NaN` → `false`
  - 문자열: 문자 시퀀스가 같으면 `true`
  - 불리언: 둘 다 `true` 또는 둘 다 `false`
  - 객체: 같은 참조일 때만 `true`

**권장사항**
- 기본값으로 무조건 `===` / `!==` 사용
- 단, NaN만 예외 처리 필요

---

### 3-3. `Object.is()` - SameValue 비교

대부분 `===`와 비슷하지만, 두 가지 중요한 차이점이 있습니다.

```javascript
// 일반적인 경우 (=== 와 동일)
Object.is(1, 1);        // true
Object.is("a", "a");    // true
Object.is({}, {});      // false (참조 다름)

// 1) NaN 처리
NaN === NaN;            // false ❌
Object.is(NaN, NaN);    // true ✅

// 2) +0 / -0 구분
0 === -0;               // true
Object.is(0, -0);       // false ✅
```

---

### 3-4. SameValueZero (Set/Map)

Set과 Map의 내부 비교는 **SameValueZero** 알고리즘을 사용합니다.

- `NaN`을 같은 값으로 취급
- `+0`과 `-0`을 같은 값으로 취급

```javascript
const set = new Set();
set.add(NaN);
set.add(NaN);
console.log(set.size); // 1 (NaN을 같은 값으로 봄)

// 하지만 코드에서 직접 비교하면
NaN === NaN; // false (여전히 false)
```

---

### 언제 무엇을 사용할까?

**일반 비즈니스 로직**
```javascript
// ✅ 항상 === / !== 사용
if (user.status === 'active') { ... }
```

**도메인 동등성**
```javascript
// ✅ 헬퍼 함수로 캡슐화
const equalsUser = (a, b) => a?.id === b?.id;
if (equalsUser(prevUser, nextUser)) { ... }
```

**Object.is 사용 케이스**
- 라이브러리/프레임워크 레벨의 얕은 비교
- React의 상태 비교 (NaN/-0 정확히 처리)
- 과학/금융 도메인에서 0과 -0 구분이 필요한 경우

---

## 4. NaN !== NaN의 철학

### 왜 NaN은 자기 자신과 같지 않은가?

```javascript
NaN === NaN;  // false
NaN == NaN;   // false
```

이것은 버그가 아니라 **IEEE 754 부동소수점 표준**의 의도된 설계입니다.

---

### IEEE 754의 철학

> "NaN은 어떤 값과도 같지 않은 값이어야 한다"

**NaN의 의미**
- "숫자가 아닌 결과(Not-a-Number)"를 나타내는 에러 플래그
- 발생 상황: 0으로 나누기, 불가능한 루트, 파싱 실패 등

**비교 동작**
```javascript
NaN === NaN;  // false
3 < NaN;      // false
3 > NaN;      // false
NaN > 3;      // false
NaN < 3;      // false
```

NaN은 **정렬 불가능한 값**으로 취급되어, 모든 비교에서 `false`를 반환합니다.

---

### 의도적으로 불편하게 만든 이유

**설계 철학**
1. 숫자 흐름에 NaN이 끼어들면 **조용히 묻히지 않고 계속 티가 나야 함**
2. 이후 연산도 모두 NaN으로 오염
3. `===` 비교에 걸리지 않게 해서 별도 검사 로직을 강제

**올바른 사용법**
```javascript
// ❌ 금지
value === NaN;

// ✅ 권장
Number.isNaN(value);

// ✅ 헬퍼 함수
const isValidNumber = (value) =>
  typeof value === "number" && !Number.isNaN(value);
```

---

### Object.is(NaN, NaN)은 왜 true인가?

```javascript
Object.is(NaN, NaN); // true
```

언어 설계상 "NaN을 같은 값으로 취급해야 할 때 쓸 수 있는 도구"를 따로 제공한 것입니다.

**철학**
- `===` / `==` : NaN을 "항상 다른 값"으로 취급 → 버그 드러내기
- `Object.is` : NaN을 "같은 NaN"으로 인식 → 정확한 비교 필요 시
- Set/Map : NaN을 같은 값으로 취급 → 중복 제거

---

## 5. 실무 가이드 체크리스트

### 동일성 vs 동등성

- **동일성(identity)**: 참조가 같은가? (`a === b` for objects)
- **동등성(equality)**: 도메인 관점에서 같은 엔티티인가? (헬퍼 함수로 정의)
- 코드 리뷰 시 "이 비교는 어떤 기준의 '같음'을 의도한 건가?" 항상 확인

### 연산자 사용 규칙

```javascript
// ❌ == 금지 (예외: value == null만 팀 합의 하에)
// ✅ === / !== 만 사용
// ✅ NaN 비교는 Number.isNaN으로만
```

### 도메인 동등성 캡슐화

```javascript
// ✅ 네이밍된 함수로 정리
const equalsUser = (a, b) => a?.id === b?.id;
const equalsProduct = (a, b) => a?.sku === b?.sku;
```

### NaN 이해하기

- "이상한 버그"가 아니라 **IEEE 754의 철학**
- 테스트/로깅에서 NaN이 보이면 계산 체인을 역추적하는 습관

---

## 마무리

동일성과 동등성, 그리고 NaN의 철학을 팀 전체가 공유하면, "이거 왜 false지?" 같은 사소하지만 시간을 잡아먹는 논쟁과 버그가 크게 줄어듭니다.
